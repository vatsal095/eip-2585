{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"src/GenericMetaTxProcessor.sol":{"content":"pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"./Libraries/BytesUtil.sol\";\nimport \"./Libraries/AddressUtils.sol\";\nimport \"./Libraries/SigUtil.sol\";\nimport \"./Libraries/SafeMath.sol\";\nimport \"./Interfaces/ERC1271.sol\";\nimport \"./Interfaces/ERC1271Constants.sol\";\nimport \"./Interfaces/ERC1654.sol\";\nimport \"./Interfaces/ERC1654Constants.sol\";\nimport \"./Interfaces/ERC20.sol\";\n\ncontract GenericMetaTxProcessor is ERC1271Constants, ERC1654Constants {\n\n    // ////////////// LIBRARIES /////////////////\n    using SafeMath for uint256;\n    using AddressUtils for address;\n    // //////////////////////////////////////////\n\n\n    // /////////////// CONSTANTS ////////////////\n    enum SignatureType { DIRECT, EIP1654, EIP1271 }\n\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,address verifyingContract)\"\n    );\n    bytes32 DOMAIN_SEPARATOR;\n\n    bytes32 constant ERC20METATRANSACTION_TYPEHASH = keccak256(\n        \"ERC20MetaTransaction(address from,address to,address tokenContract,uint256 amount,bytes data,uint256 batchId,uint256 batchNonce,uint256 expiry,uint256 txGas,uint256 baseGas,uint256 tokenGasPrice,address relayer)\"\n    );\n    // //////////////////////////////////////////\n\n    // //////////////// EVENTS //////////////////\n    event MetaTx(\n        address indexed from,\n        uint256 indexed batchId,\n        uint256 indexed batchNonce,\n        bool success,\n        bytes returnData\n    ); // TODO specify event as part of ERC-1776 ?\n    // //////////////////////////////////////////\n\n    // //////////////// STATE ///////////////////\n    mapping(address => mapping(uint256 => uint256)) batches;\n    bool lock = false;\n    // //////////////////////////////////////////\n\n    constructor() public {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(\"Generic Meta Transaction\"),\n                keccak256(\"1\"),\n                address(this)\n            )\n        );\n    }\n\n    struct Call {\n        address from;\n        address to;\n        bytes data;\n        bytes signature;\n        SignatureType signatureType;\n    }\n\n    struct CallParams {\n        address tokenContract;\n        uint256 amount;\n        uint256 batchId;\n        uint256 batchNonce;\n        uint256 expiry;\n        uint256 txGas;\n        uint256 baseGas;\n        uint256 tokenGasPrice;\n        address relayer;\n    }\n\n    function executeMetaTransaction(\n        Call memory callData,\n        CallParams memory callParams,\n        address tokenReceiver\n    ) public returns (bool success, bytes memory returnData) {\n        require(!lock, \"IN_PROGRESS\");\n        lock = true;\n        _ensureParametersValidity(callData, callParams);\n        _ensureCorrectSigner(callData, callParams);\n        (success, returnData) = _performERC20MetaTx(callData, callParams, tokenReceiver);\n        lock = false;\n    }\n\n    // ////////////////////////////// INTERNALS /////////////////////////\n\n    function _ensureParametersValidity(\n        Call memory callData,\n        CallParams memory callParams\n    ) internal view {\n        require(\n            callParams.relayer == address(0) || callParams.relayer == msg.sender,\n            \"wrong relayer\"\n        );\n        require(block.timestamp < callParams.expiry, \"expired\");\n        require(batches[callData.from][callParams.batchId] + 1 == callParams.batchNonce, \"batchNonce out of order\");\n    }\n\n    function _encodeMessage(\n        Call memory callData,\n        CallParams memory callParams\n    ) internal view returns (bytes memory) {\n        return abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR,\n            keccak256(messageBytes(callData, callParams))\n        );\n    }\n\n    function messageBytes(\n        Call memory callData,\n        CallParams memory callParams\n    ) internal pure returns(bytes memory) {\n        return abi.encode(\n            ERC20METATRANSACTION_TYPEHASH,\n            callData.from,\n            callData.to,\n            callParams.tokenContract,\n            callParams.amount,\n            keccak256(callData.data),\n            callParams.batchId,\n            callParams.batchNonce,\n            callParams.expiry,\n            callParams.txGas,\n            callParams.baseGas,\n            callParams.tokenGasPrice,\n            callParams.relayer\n        );\n    }\n\n    function _ensureCorrectSigner(\n        Call memory callData,\n        CallParams memory callParams\n    ) internal view {\n        bytes memory dataToHash = _encodeMessage(callData, callParams);\n        if (callData.signatureType == SignatureType.EIP1271) {\n            require(\n                ERC1271(callData.from).isValidSignature(dataToHash, callData.signature) == ERC1271_MAGICVALUE,\n                \"invalid 1271 signature\"\n            );\n        } else if(callData.signatureType == SignatureType.EIP1654){\n            require(\n                ERC1654(callData.from).isValidSignature(keccak256(dataToHash), callData.signature) == ERC1654_MAGICVALUE,\n                \"invalid 1654 signature\"\n            );\n        } else {\n            address signer = SigUtil.recover(keccak256(dataToHash), callData.signature);\n            require(signer == callData.from, \"signer != from\");\n        }\n    }\n\n    function _charge(\n        address from,\n        ERC20 tokenContract,\n        uint256 gasLimit,\n        uint256 tokenGasPrice,\n        uint256 initialGas,\n        uint256 baseGasCharge,\n        address tokenReceiver\n    ) internal {\n        uint256 gasCharge = initialGas - gasleft();\n        if(gasCharge > gasLimit) {\n            gasCharge = gasLimit;\n        }\n        gasCharge += baseGasCharge;\n        uint256 tokensToCharge = gasCharge * tokenGasPrice;\n        require(tokensToCharge / gasCharge == tokenGasPrice, \"overflow\");\n        tokenContract.transferFrom(from, tokenReceiver, tokensToCharge);\n    }\n\n    function _executeWithSpecificGas(\n        address to,\n        uint256 gasLimit,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        (success, returnData) = to.call.gas(gasLimit)(data);\n        assert(gasleft() > gasLimit / 63); // not enough gas provided, assert to throw all gas // TODO use EIP-1930\n    }\n\n    function _transferAndChargeForGas(\n        address from,\n        address to,\n        ERC20 tokenContract,\n        uint256 amount,\n        uint256 gasLimit,\n        uint256 tokenGasPrice,\n        uint256 baseGasCharge,\n        address tokenReceiver\n    ) internal returns (bool) {\n        uint256 initialGas = gasleft();\n        tokenContract.transferFrom(from, to, amount);\n        if (tokenGasPrice > 0) {\n            _charge(from, tokenContract, gasLimit, tokenGasPrice, initialGas, baseGasCharge, tokenReceiver);\n        }\n        return true;\n    }\n\n    function _executeWithSpecificGasAndChargeForIt(\n        address from,\n        address to,\n        ERC20 tokenContract,\n        uint256 gasLimit,\n        uint256 tokenGasPrice,\n        uint256 baseGasCharge,\n        address tokenReceiver,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        uint256 initialGas = gasleft();\n        (success, returnData) = _executeWithSpecificGas(to, gasLimit, data);\n        if (tokenGasPrice > 0) {\n            _charge(from, tokenContract, gasLimit, tokenGasPrice, initialGas, baseGasCharge, tokenReceiver);\n        }\n    }\n\n    function _performERC20MetaTx(\n        Call memory callData,\n        CallParams memory callParams,\n        address tokenReceiver\n    ) internal returns (bool success, bytes memory returnData) {\n        batches[callData.from][callParams.batchId] = callParams.batchNonce;\n\n        ERC20 tokenContract = ERC20(callParams.tokenContract);\n\n        if (callData.data.length == 0) {\n            if(callParams.tokenGasPrice > 0) {\n                _transferAndChargeForGas(\n                    callData.from,\n                    callData.to,\n                    tokenContract,\n                    callParams.amount,\n                    callParams.txGas,\n                    callParams.tokenGasPrice,\n                    callParams.baseGas,\n                    tokenReceiver\n                );\n            } else {\n                require(tokenContract.transferFrom(callData.from, callData.to, callParams.amount), \"ERC20_TRANSFER_FAILED\");\n            }\n            success = true;\n        } else {\n            require(\n                BytesUtil.doFirstParamEqualsAddress(callData.data, callData.from),\n                \"first param != from\"\n            );\n            uint256 previousBalance;\n            if(callParams.amount > 0) {\n                previousBalance = tokenContract.balanceOf(address(this));\n                require(tokenContract.transferFrom(callData.from, address(this), callParams.amount), \"ERC20_ALLOCATION_FAILED\");\n                tokenContract.approve(callData.to, callParams.amount);\n            }\n            if(callParams.tokenGasPrice > 0) {\n                (success, returnData) = _executeWithSpecificGasAndChargeForIt(\n                    callData.from,\n                    callData.to,\n                    tokenContract,\n                    callParams.txGas,\n                    callParams.tokenGasPrice,\n                    callParams.baseGas,\n                    tokenReceiver,\n                    callData.data\n                );\n            } else {\n                (success, returnData) = _executeWithSpecificGas(callData.to, callParams.txGas, callData.data);\n            }\n            if(callParams.amount > 0) {\n                uint256 newBalance = tokenContract.balanceOf(address(this));\n                if (newBalance > previousBalance) {\n                    require(tokenContract.transfer(callData.from, newBalance - previousBalance), \"ERC20_REFUND_FAILED\");\n                }\n            }\n        }\n\n        emit MetaTx(callData.from, callParams.batchId, callParams.batchNonce, success, returnData);\n    }\n\n    function meta_nonce(address from, uint256 batchId) external view returns(uint256) {\n        return batches[from][batchId];\n    }\n}\n","keccak256":"0x978e4629751fe117530f25323bce657eedd285a99dc444422e270322388baeef"},"src/Interfaces/ERC1271.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface ERC1271 {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param data Arbitrary length data signed on the behalf of address(this)\n    * @param signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */\n    function isValidSignature(bytes calldata data, bytes calldata signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n","keccak256":"0xd47b461d487409fbb422a86f77818cf4c3a904d21c80b7df63c42f5b114da68f"},"src/Interfaces/ERC1271Constants.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract ERC1271Constants {\n    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;\n}\n","keccak256":"0xe699d97bb95be085cbb795821dd52673088d58d96976e26a0b066a856a6c1f3d"},"src/Interfaces/ERC1654.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface ERC1654 {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided hash\n    * @param hash 32 bytes hash to be signed\n    * @param signature Signature byte array associated with hash\n    * @return magicValue 0x1626ba7e if valid else 0x00000000\n    */\n    function isValidSignature(bytes32 hash, bytes calldata signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n","keccak256":"0x4f006eeed4fdb08128571445ecdc75e13858dee0b7876431b46f75a2d9d9ff6a"},"src/Interfaces/ERC1654Constants.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract ERC1654Constants {\n    bytes4 internal constant ERC1654_MAGICVALUE = 0x1626ba7e;\n}\n","keccak256":"0xd7650a572f69557bd6dfe3701a5bf02fd7148a127d7ec4a05dde59fca4ef19dd"},"src/Interfaces/ERC20.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value)\n        external\n        returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\n","keccak256":"0x6c28b4e23b6c521272670898110501a09e957e790f694725aa749fd8c8e2142a"},"src/Libraries/AddressUtils.sol":{"content":"pragma solidity ^0.6.0;\n\nlibrary AddressUtils {\n\n    function toPayable(address _address) internal pure returns (address payable _payable) {\n        return address(uint160(_address));\n    }\n\n    function isContract(address addr) internal view returns (bool) {\n        // for accounts without code, i.e. `keccak256('')`:\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        bytes32 codehash;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n","keccak256":"0xeac7dc828dbde8ad86c624d39dca24f7f66c3986958d8a71cd69a6aa9b5ed679"},"src/Libraries/BytesUtil.sol":{"content":"pragma solidity ^0.6.0;\n\nlibrary BytesUtil {\n    function memcpy(uint256 dest, uint256 src, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function pointerToBytes(uint256 src, uint256 len)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory ret = new bytes(len);\n        uint256 retptr;\n        assembly {\n            retptr := add(ret, 32)\n        }\n\n        memcpy(retptr, src, len);\n        return ret;\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(\n                add(m, 20),\n                xor(0x140000000000000000000000000000000000000000, a)\n            )\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 32), a)\n            mstore(0x40, add(m, 64))\n            b := m\n        }\n    }\n\n    function doFirstParamEqualsAddress(bytes memory data, address _address)\n        internal\n        pure\n        returns (bool)\n    {\n        if (data.length < (36 + 32)) {\n            return false;\n        }\n        uint256 value;\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(_address);\n    }\n\n    function doParamEqualsUInt256(bytes memory data, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bool)\n    {\n        if (data.length < (36 + (i + 1) * 32)) {\n            return false;\n        }\n        uint256 offset = 36 + i * 32;\n        uint256 valuePresent;\n        assembly {\n            valuePresent := mload(add(data, offset))\n        }\n        return valuePresent == value;\n    }\n\n    function overrideFirst32BytesWithAddress(\n        bytes memory data,\n        address _address\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n\n        bytes memory addressBytes = addressToBytes(_address);\n        uint256 src;\n        assembly {\n            src := add(addressBytes, 32)\n        }\n\n        memcpy(dest, src, 20);\n        return data;\n    }\n\n    function overrideFirstTwo32BytesWithAddressAndInt(\n        bytes memory data,\n        address _address,\n        uint256 _value\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n        bytes memory bbytes = addressToBytes(_address);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 20);\n\n        assembly {\n            dest := add(data, 68)\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\n        bbytes = uint256ToBytes(_value);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 32);\n\n        return data;\n    }\n}\n","keccak256":"0xbc2e25a5e410c9f7889beb483fe471a6aa55997ac0d3bafabd5042451a806529"},"src/Libraries/SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        require(c / a == b, \"overflow\");\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"undeflow\");\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a, \"overflow\");\n        return c;\n    }\n}\n","keccak256":"0x77a1483e56a10a93ab2d6b8ae7bd9a40d10e1c0edb9583cce13493b5549bf199"},"src/Libraries/SigUtil.sol":{"content":"pragma solidity ^0.6.0;\n\nlibrary SigUtil {\n    function recover(bytes32 hash, bytes memory sig)\n        internal\n        pure\n        returns (address recovered)\n    {\n        require(sig.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        require(v == 27 || v == 28);\n\n        recovered = ecrecover(hash, v, r, s);\n        require(recovered != address(0));\n    }\n\n    function recoverWithZeroOnFailure(bytes32 hash, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        if (sig.length != 65) {\n            return (address(0));\n        }\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes memory) {\n        return abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash);\n    }\n}\n","keccak256":"0x779ab6a267e945cd0f164fecf7f6366888e3f1bb36730391b47fd70d52a8f222"}}}