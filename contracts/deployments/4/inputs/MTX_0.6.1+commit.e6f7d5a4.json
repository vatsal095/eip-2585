{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"src/Interfaces/ERC20.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value)\n        external\n        returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\n","keccak256":"0x6c28b4e23b6c521272670898110501a09e957e790f694725aa749fd8c8e2142a"},"src/Test/PAW.sol":{"content":"pragma solidity 0.6.1;\n\nimport \"../Interfaces/ERC20.sol\";\n\ncontract PAW /*is ERC20*/{ // interface seems to require overrides :(\n\n     // --- EIP712 niceties ---\n    bytes32 public /*immutable*/ DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n    mapping (address => uint256) public nonces;\n    string  public constant name     = \"Dai Stablecoin\";\n    string  public constant symbol   = \"DAI\";\n    string  public constant version  = \"1\";\n\n    ///////////////// EVENTS FOR ERC20 ////////////////\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    ///////////////////////////////////////////////////\n\n    uint256 internal /*immutable*/ _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _supplyClaimed;\n    mapping(address => bool) internal _claimed; // TODO optimize it by storing it in the same slot as _balances\n    address internal /*immutable*/ _metaTxProcessor;\n\n    constructor(uint256 supply, address metaTxProcessor) public {\n        _metaTxProcessor = metaTxProcessor;\n        _totalSupply = supply;\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            address(this)\n        ));\n    }\n\n    /// @notice Gets the total number of tokens in existence.\n    /// @return the total number of tokens in existence.\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    // function hasClaimed() TODO\n\n    function _balanceOf(address owner) internal view returns (bool claimed, uint256 balance) {\n        balance = _balances[owner];\n        if (!_claimed[owner] && _supplyClaimed < _totalSupply) {\n            claimed = false;\n            balance = _totalSupply - _supplyClaimed;\n            if (balance > 10000000000000000000) {\n                balance = 10000000000000000000;\n            }\n        } else {\n            claimed = true;\n        }\n    }\n\n    /// @notice Gets the balance of `owner`.\n    /// @param owner The address to query the balance of.\n    /// @return The amount owned by `owner`.\n    function balanceOf(address owner) public view returns (uint256) {\n        (bool _, uint256 balance) = _balanceOf(owner);\n        return balance;\n    }\n\n    /// @notice gets allowance of `spender` for `owner`'s tokens.\n    /// @param owner address whose token is allowed.\n    /// @param spender address allowed to transfer.\n    /// @return remaining the amount of token `spender` is allowed to transfer on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint256 remaining)\n    {\n        if(spender != address(0) && spender == _metaTxProcessor) {\n            return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        }\n        return _allowances[owner][spender];\n    }\n\n    /// @notice returns the number of decimals for that token.\n    /// @return the number of decimals.\n    function decimals() public view returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @notice Transfer `amount` tokens to `to`.\n    /// @param to the recipient address of the tokens transfered.\n    /// @param amount the number of tokens transfered.\n    /// @return success true if success.\n    function transfer(address to, uint256 amount)\n        public\n        returns (bool success)\n    {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `from` to `to`.\n    /// @param from whose token it is transferring from.\n    /// @param to the recipient address of the tokens transfered.\n    /// @param amount the number of tokens transfered.\n    /// @return success true if success.\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != from && msg.sender != _metaTxProcessor) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != (2**256) - 1) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"Not enough funds allowed\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    // /// @notice burn `amount` tokens.\n    // /// @param amount the number of tokens to burn.\n    // /// @return true if success.\n    // function burn(uint256 amount) external returns (bool) {\n    //     _burn(msg.sender, amount);\n    //     return true;\n    // }\n\n    // /// @notice burn `amount` tokens from `owner`.\n    // /// @param owner address whose token is to burn.\n    // /// @param amount the number of token to burn.\n    // /// @return true if success.\n    // function burnFor(address owner, uint256 amount) external returns (bool) {\n    //     _burn(owner, amount);\n    //     return true;\n    // }\n\n    /// @notice approve `spender` to transfer `amount` tokens.\n    /// @param spender address to be given rights to transfer.\n    /// @param amount the number of tokens allowed.\n    /// @return success true if success.\n    function approve(address spender, uint256 amount)\n        public\n        returns (bool success)\n    {\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice approve `spender` to transfer `amount` tokens from `owner`.\n    /// @param owner address whose token is allowed.\n    /// @param spender  address to be given rights to transfer.\n    /// @param amount the number of tokens allowed.\n    /// @return success true if success.\n    function approveFor(address owner, address spender, uint256 amount)\n        public\n        returns (bool success)\n    {\n        require(\n            msg.sender == owner,\n            \"msg.sender != owner\"\n        );\n        _approveFor(owner, spender, amount);\n        return true;\n    }\n\n\n    function _approveFor(address owner, address spender, uint256 amount)\n        internal\n    {\n        require(\n            owner != address(0) && spender != address(0),\n            \"Cannot approve with 0x0\"\n        );\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"Cannot send to 0x0\");\n        (bool claimed, uint256 currentBalance) = _balanceOf(from);\n        require(currentBalance >= amount, \"not enough fund\");\n        if (!claimed) {\n            _supplyClaimed += currentBalance;\n            _claimed[from] = true; // TODO use bit in _balances to reuse same slot\n        }\n        _balances[from] = currentBalance - amount;\n\n        (claimed, currentBalance) = _balanceOf(to);\n        if (!claimed) {\n            _supplyClaimed += currentBalance;\n            _claimed[to] = true; // TODO use bit in _balances to reuse same slot\n        }\n        _balances[to] = currentBalance + amount;\n        emit Transfer(from, to, amount);\n    }\n\n    // function _mint(address to, uint256 amount) internal {\n    //     require(to != address(0), \"Cannot mint to 0x0\");\n    //     require(amount > 0, \"cannot mint 0 tokens\");\n    //     uint256 currentTotalSupply = _totalSupply;\n    //     uint256 newTotalSupply = currentTotalSupply + amount;\n    //     require(newTotalSupply > currentTotalSupply, \"overflow\");\n    //     _totalSupply = newTotalSupply;\n    //     _balances[to] += amount;\n    //     emit Transfer(address(0), to, amount);\n    // }\n\n    // function _burn(address from, uint256 amount) internal {\n    //     require(amount > 0, \"cannot burn 0 tokens\");\n    //     if (msg.sender != from) {\n    //         uint256 currentAllowance = _allowances[from][msg.sender];\n    //         require(\n    //             currentAllowance >= amount,\n    //             \"Not enough funds allowed\"\n    //         );\n    //         if (currentAllowance != (2**256) - 1) {\n    //             // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n    //             _allowances[from][msg.sender] = currentAllowance - amount;\n    //         }\n    //     }\n\n    //     uint256 currentBalance = balanceOf(from);\n    //     require(currentBalance >= amount, \"Not enough funds\");\n    //     _balances[from] = currentBalance - amount;\n    //     _totalSupply -= amount;\n    //     emit Transfer(from, address(0), amount);\n    // }\n\n    // --- Approve by signature ---\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\n    {\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     holder,\n                                     spender,\n                                     nonce,\n                                     expiry,\n                                     allowed))\n        ));\n\n        require(holder != address(0), \"Dai/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\n        require(expiry == 0 || now <= expiry, \"Dai/permit-expired\");\n        require(nonce == nonces[holder]++, \"Dai/invalid-nonce\");\n        uint wad = allowed ? uint(-1) : 0;\n        _allowances[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n}\n","keccak256":"0xec82c958ca88eff94163197e4cce71064026ba70160dce25bae5b20b4163ba94"}}}