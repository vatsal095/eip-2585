{
  "contractInfo": {
    "abi": [
      {
        "inputs": [
          {
            "internalType": "contract Numbers",
            "name": "numbers",
            "type": "address"
          },
          {
            "internalType": "contract ERC20",
            "name": "erc20Token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "price",
            "type": "uint256"
          },
          {
            "internalType": "address",
            "name": "metaTxProcessor",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "from",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "to",
            "type": "address"
          }
        ],
        "name": "purchase",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      }
    ],
    "evm": {
      "bytecode": {
        "linkReferences": {},
        "object": "608060405234801561001057600080fd5b506040516102e83803806102e88339818101604052608081101561003357600080fd5b50805160208201516040830151606090930151600080546001600160a01b039283166001600160a01b031991821617909155600180549483169482169490941790935560028054919092169216919091179055600355610250806100986000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063dde5a65d14610030575b600080fd5b61005e6004803603604081101561004657600080fd5b506001600160a01b0381358116916020013516610060565b005b610069826101e7565b6100ab576040805162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b604482015290519081900360640190fd5b600254600354604080516323b872dd60e01b81523360048201523060248201526044810192909252516001600160a01b03909216916323b872dd916064808201926020929091908290030181600087803b15801561010857600080fd5b505af115801561011c573d6000803e3d6000fd5b505050506040513d602081101561013257600080fd5b505161017d576040805162461bcd60e51b8152602060048201526015602482015274115490cc8c17d514905394d1915497d19052531151605a1b604482015290519081900360640190fd5b600154604080516335313c2160e11b81526001600160a01b03848116600483015291519190921691636a62784291602480830192600092919082900301818387803b1580156101cb57600080fd5b505af11580156101df573d6000803e3d6000fd5b505050505050565b6000336001600160a01b03831614806102035750610203610209565b92915050565b6000546001600160a01b031633149056fea2646970667358221220dcdfbd9f6bba877ed869321ffa473d5e2f827ba26dea4ada24f08fe004544f7264736f6c63430006010033",
        "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH2 0x2E8 CODESIZE SUB DUP1 PUSH2 0x2E8 DUP4 CODECOPY DUP2 DUP2 ADD PUSH1 0x40 MSTORE PUSH1 0x80 DUP2 LT ISZERO PUSH2 0x33 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP DUP1 MLOAD PUSH1 0x20 DUP3 ADD MLOAD PUSH1 0x40 DUP4 ADD MLOAD PUSH1 0x60 SWAP1 SWAP4 ADD MLOAD PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT SWAP2 DUP3 AND OR SWAP1 SWAP2 SSTORE PUSH1 0x1 DUP1 SLOAD SWAP5 DUP4 AND SWAP5 DUP3 AND SWAP5 SWAP1 SWAP5 OR SWAP1 SWAP4 SSTORE PUSH1 0x2 DUP1 SLOAD SWAP2 SWAP1 SWAP3 AND SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE PUSH1 0x3 SSTORE PUSH2 0x250 DUP1 PUSH2 0x98 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x2B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xDDE5A65D EQ PUSH2 0x30 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x5E PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x46 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD DUP2 AND SWAP2 PUSH1 0x20 ADD CALLDATALOAD AND PUSH2 0x60 JUMP JUMPDEST STOP JUMPDEST PUSH2 0x69 DUP3 PUSH2 0x1E7 JUMP JUMPDEST PUSH2 0xAB JUMPI PUSH1 0x40 DUP1 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xE PUSH1 0x24 DUP3 ADD MSTORE PUSH14 0x1393D517D055551213D492569151 PUSH1 0x92 SHL PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x2 SLOAD PUSH1 0x3 SLOAD PUSH1 0x40 DUP1 MLOAD PUSH4 0x23B872DD PUSH1 0xE0 SHL DUP2 MSTORE CALLER PUSH1 0x4 DUP3 ADD MSTORE ADDRESS PUSH1 0x24 DUP3 ADD MSTORE PUSH1 0x44 DUP2 ADD SWAP3 SWAP1 SWAP3 MSTORE MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 PUSH4 0x23B872DD SWAP2 PUSH1 0x64 DUP1 DUP3 ADD SWAP3 PUSH1 0x20 SWAP3 SWAP1 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x108 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x11C JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x132 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH2 0x17D JUMPI PUSH1 0x40 DUP1 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x15 PUSH1 0x24 DUP3 ADD MSTORE PUSH21 0x115490CC8C17D514905394D1915497D19052531151 PUSH1 0x5A SHL PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x1 SLOAD PUSH1 0x40 DUP1 MLOAD PUSH4 0x35313C21 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 DUP2 AND PUSH1 0x4 DUP4 ADD MSTORE SWAP2 MLOAD SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH4 0x6A627842 SWAP2 PUSH1 0x24 DUP1 DUP4 ADD SWAP3 PUSH1 0x0 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP4 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x1CB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x1DF JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 CALLER PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND EQ DUP1 PUSH2 0x203 JUMPI POP PUSH2 0x203 PUSH2 0x209 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ SWAP1 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xDC 0xDF 0xBD SWAP16 PUSH12 0xBA877ED869321FFA473D5E2F DUP3 PUSH28 0xA26DEA4ADA24F08FE004544F7264736F6C6343000601003300000000 ",
        "sourceMap": "126:1201:17:-:0;;;316:230;8:9:-1;5:2;;;30:1;27;20:12;5:2;316:230:17;;;;;;;;;;;;;;;13:3:-1;8;5:12;2:2;;;30:1;27;20:12;2:2;-1:-1;316:230:17;;;;;;;;;;;;;;;160:16:0;:34;;-1:-1:-1;;;;;160:34:0;;;-1:-1:-1;;;;;;160:34:0;;;;;;;;463:18:17;;;;::::1;::::0;;::::1;::::0;;;::::1;::::0;;;491:11:::1;:24:::0;;;;;::::1;::::0;::::1;::::0;;;::::1;::::0;;525:6:::1;:14:::0;126:1201;;;;;;"
      },
      "deployedBytecode": {
        "linkReferences": {},
        "object": "608060405234801561001057600080fd5b506004361061002b5760003560e01c8063dde5a65d14610030575b600080fd5b61005e6004803603604081101561004657600080fd5b506001600160a01b0381358116916020013516610060565b005b610069826101e7565b6100ab576040805162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b604482015290519081900360640190fd5b600254600354604080516323b872dd60e01b81523360048201523060248201526044810192909252516001600160a01b03909216916323b872dd916064808201926020929091908290030181600087803b15801561010857600080fd5b505af115801561011c573d6000803e3d6000fd5b505050506040513d602081101561013257600080fd5b505161017d576040805162461bcd60e51b8152602060048201526015602482015274115490cc8c17d514905394d1915497d19052531151605a1b604482015290519081900360640190fd5b600154604080516335313c2160e11b81526001600160a01b03848116600483015291519190921691636a62784291602480830192600092919082900301818387803b1580156101cb57600080fd5b505af11580156101df573d6000803e3d6000fd5b505050505050565b6000336001600160a01b03831614806102035750610203610209565b92915050565b6000546001600160a01b031633149056fea2646970667358221220dcdfbd9f6bba877ed869321ffa473d5e2f827ba26dea4ada24f08fe004544f7264736f6c63430006010033",
        "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x2B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xDDE5A65D EQ PUSH2 0x30 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x5E PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x46 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD DUP2 AND SWAP2 PUSH1 0x20 ADD CALLDATALOAD AND PUSH2 0x60 JUMP JUMPDEST STOP JUMPDEST PUSH2 0x69 DUP3 PUSH2 0x1E7 JUMP JUMPDEST PUSH2 0xAB JUMPI PUSH1 0x40 DUP1 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xE PUSH1 0x24 DUP3 ADD MSTORE PUSH14 0x1393D517D055551213D492569151 PUSH1 0x92 SHL PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x2 SLOAD PUSH1 0x3 SLOAD PUSH1 0x40 DUP1 MLOAD PUSH4 0x23B872DD PUSH1 0xE0 SHL DUP2 MSTORE CALLER PUSH1 0x4 DUP3 ADD MSTORE ADDRESS PUSH1 0x24 DUP3 ADD MSTORE PUSH1 0x44 DUP2 ADD SWAP3 SWAP1 SWAP3 MSTORE MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 PUSH4 0x23B872DD SWAP2 PUSH1 0x64 DUP1 DUP3 ADD SWAP3 PUSH1 0x20 SWAP3 SWAP1 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x108 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x11C JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x132 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH2 0x17D JUMPI PUSH1 0x40 DUP1 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x15 PUSH1 0x24 DUP3 ADD MSTORE PUSH21 0x115490CC8C17D514905394D1915497D19052531151 PUSH1 0x5A SHL PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x1 SLOAD PUSH1 0x40 DUP1 MLOAD PUSH4 0x35313C21 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 DUP2 AND PUSH1 0x4 DUP4 ADD MSTORE SWAP2 MLOAD SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH4 0x6A627842 SWAP2 PUSH1 0x24 DUP1 DUP4 ADD SWAP3 PUSH1 0x0 SWAP3 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP4 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x1CB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x1DF JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 CALLER PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND EQ DUP1 PUSH2 0x203 JUMPI POP PUSH2 0x203 PUSH2 0x209 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ SWAP1 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xDC 0xDF 0xBD SWAP16 PUSH12 0xBA877ED869321FFA473D5E2F DUP3 PUSH28 0xA26DEA4ADA24F08FE004544F7264736F6C6343000601003300000000 ",
        "sourceMap": "126:1201:17:-:0;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;126:1201:17;;;;;;;;;;;;;;;;;;;552:773;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;-1:-1;;;;;;552:773:17;;;;;;;;;;:::i;:::-;;;878:19;892:4;878:13;:19::i;:::-;870:46;;;;;-1:-1:-1;;;870:46:17;;;;;;;;;;;;-1:-1:-1;;;870:46:17;;;;;;;;;;;;;;;1171:11;;1223:6;;1171:59;;;-1:-1:-1;;;1171:59:17;;1196:10;1171:59;;;;1216:4;1171:59;;;;;;;;;;;;-1:-1:-1;;;;;1171:11:17;;;;:24;;:59;;;;;;;;;;;;;;;:11;;:59;;;5:2:-1;;;;30:1;27;20:12;5:2;1171:59:17;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;1171:59:17;;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;-1:-1;1171:59:17;1163:93;;;;;-1:-1:-1;;;1163:93:17;;;;;;;;;;;;-1:-1:-1;;;1163:93:17;;;;;;;;;;;;;;;1301:8;;:17;;;-1:-1:-1;;;1301:17:17;;-1:-1:-1;;;;;1301:17:17;;;;;;;;;:8;;;;;:13;;:17;;;;;:8;;:17;;;;;;;:8;;:17;;;5:2:-1;;;;30:1;27;20:12;5:2;1301:17:17;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;1301:17:17;;;;552:773;;:::o;304:121:0:-;363:4;386:10;-1:-1:-1;;;;;386:18:0;;;;:32;;;408:10;:8;:10::i;:::-;379:39;304:121;-1:-1:-1;;304:121:0:o;431:102::-;473:4;510:16;-1:-1:-1;;;;;510:16:0;496:10;:30;;431:102::o"
      },
      "methodIdentifiers": {
        "purchase(address,address)": "dde5a65d"
      }
    },
    "metadata": "{\"compiler\":{\"version\":\"0.6.1+commit.e6f7d5a4\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract Numbers\",\"name\":\"numbers\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"metaTxProcessor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/Test/NumberSale.sol\":\"NumberSale\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"src/EIP1776MetaTxReceiverBase.sol\":{\"content\":\"pragma solidity 0.6.1;\\n\\ncontract EIP1776MetaTxReceiverBase {\\n\\n    address private _metaTxProcessor;\\n    constructor(address metaTxProcessor) internal {\\n        _metaTxProcessor = metaTxProcessor;\\n    }\\n\\n    ///@dev the from need to be equal to the first parameter of the function using that modifier\\n    function isValidSender(address from) internal view returns(bool) {\\n        return msg.sender == from || isMetaTx();\\n    }\\n\\n    function isMetaTx() internal view returns(bool) {\\n        return msg.sender == _metaTxProcessor;\\n    }\\n}\\n\",\"keccak256\":\"0x4d36cc539b5ec0fc2dec57a981af90afc8212e2c7bb2a8273e6fb508b0f92d32\"},\"src/Interfaces/ERC165.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @title ERC165\\n * @dev https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface ERC165 {\\n    /**\\n   * @notice Query if a contract implements interface `interfaceId`\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @dev Interface identification is specified in ERC-165. This function\\n   * uses less than 30,000 gas.\\n   */\\n    function supportsInterface(bytes4 interfaceId)\\n        external\\n        view\\n        returns (bool);\\n}\\n\",\"keccak256\":\"0xc0faa36cba688ce34574fdab3aaae02fc8255999ceec19998d4c22065a1754f8\"},\"src/Interfaces/ERC20.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface ERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value)\\n        external\\n        returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0x6c28b4e23b6c521272670898110501a09e957e790f694725aa749fd8c8e2142a\"},\"src/Interfaces/ERC721.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\ninterface ERC721 /*is ERC165*/ { // Interfaces still cannot inherit :(\\n    event Transfer(\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 indexed _tokenId\\n    );\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _approved,\\n        uint256 indexed _tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed _owner,\\n        address indexed _operator,\\n        bool _approved\\n    );\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    \\n    function approve(address to, uint256 tokenId) external;\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 tokenId)\\n        external;\\n    function safeTransferFrom(address from, address to, uint256 tokenId)\\n        external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6796e307cbd33d1d26c0861a2c8c775570db0482cbbd1b66541b2a1af6a9623e\"},\"src/Interfaces/ERC721Enumerable.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\\ninterface ERC721Enumerable /* is ERC721 */ {\\n    /// @notice Count NFTs tracked by this contract\\n    /// @return A count of valid NFTs tracked by this contract, where each one of\\n    ///  them has an assigned and queryable owner not equal to the zero address\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Enumerate valid NFTs\\n    /// @dev Throws if `_index` >= `totalSupply()`.\\n    /// @param _index A counter less than `totalSupply()`\\n    /// @return The token identifier for the `_index`th NFT,\\n    ///  (sort order not specified)\\n    function tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n    /// @notice Enumerate NFTs assigned to an owner\\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n    ///  `_owner` is the zero address, representing invalid NFTs.\\n    /// @param _owner An address where we are interested in NFTs owned by them\\n    /// @param _index A counter less than `balanceOf(_owner)`\\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n    ///   (sort order not specified)\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\",\"keccak256\":\"0xdd15c10b403e5bb1d1f86c403ee9d589d51a1d07193def74c71eece7696a3f71\"},\"src/Interfaces/ERC721TokenReceiver.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x1e7dcf369cd4048ef656ea016905f9ab78956d4ab88ddd9fc941e72128bb0c72\"},\"src/Libraries/AddressUtils.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nlibrary AddressUtils {\\n\\n    function toPayable(address _address) internal pure returns (address payable _payable) {\\n        return address(uint160(_address));\\n    }\\n\\n    function isContract(address addr) internal view returns (bool) {\\n        // for accounts without code, i.e. `keccak256('')`:\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n        bytes32 codehash;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(addr)\\n        }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n}\\n\",\"keccak256\":\"0xeac7dc828dbde8ad86c624d39dca24f7f66c3986958d8a71cd69a6aa9b5ed679\"},\"src/Test/NumberSale.sol\":{\"content\":\"pragma solidity 0.6.1;\\n\\nimport \\\"../EIP1776MetaTxReceiverBase.sol\\\";\\nimport \\\"./Numbers.sol\\\";\\nimport \\\"../Interfaces/ERC20.sol\\\";\\n\\ncontract NumberSale is EIP1776MetaTxReceiverBase {\\n\\n    Numbers internal /*immutable*/ _numbers;\\n    ERC20 internal /*immutable*/ _erc20Token;\\n    uint256 internal /*immutable*/ _price;\\n    constructor(Numbers numbers, ERC20 erc20Token, uint256 price, address metaTxProcessor) public EIP1776MetaTxReceiverBase(metaTxProcessor) {\\n        _numbers = numbers;\\n        _erc20Token = erc20Token;\\n        _price = price;\\n    }\\n\\n    function purchase(address from, address to) external {\\n\\n        // this check whether\\n        // 1) the first parameter is msg.sender, in which case the user is using a normal tx\\n        // 2) or the msg.sender is equal the MetatxProcessor (which ensure the first paramter is the address of the metatx signer)\\n        require(isValidSender(from), \\\"NOT_AUTHORIZED\\\");\\n\\n\\n        // Here we transfer from the sender\\n        // this works because the meta tx processor will be owing the ERC20 token temporarly\\n        // This allow the user to never need to approve ERC20 token before hand when using metatx\\n        require(_erc20Token.transferFrom(msg.sender, address(this), _price), \\\"ERC20_TRANSFER_FAILED\\\");\\n\\n        // if all is good we mint\\n        _numbers.mint(to);\\n    }\\n}\\n\",\"keccak256\":\"0x4d8abc5dc915d072e787730ec4e484d50482e515927970586513c6f63ba4f0c0\"},\"src/Test/Numbers.sol\":{\"content\":\"pragma solidity 0.6.1;\\n\\nimport \\\"../Libraries/AddressUtils.sol\\\";\\nimport \\\"../Interfaces/ERC721TokenReceiver.sol\\\";\\nimport \\\"../Interfaces/ERC721.sol\\\";\\nimport \\\"../Interfaces/ERC721Enumerable.sol\\\";\\n\\nimport \\\"../EIP1776MetaTxReceiverBase.sol\\\";\\n\\ncontract Numbers is /*ERC721, ERC721Enumerable,*/ EIP1776MetaTxReceiverBase { // interface seems to require overrides :(\\n\\n    //////////////////////////// ERC721 Events /////////////\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n    /////////////////////////////////////////////////////////\\n\\n\\n    using AddressUtils for address;\\n\\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\\n\\n    mapping(uint256 => uint256) _ownerAndIndex; // max 2**96 items, store both owner and item index\\n    mapping(address => uint256[]) _itemsPerOwner;\\n    mapping (address => mapping(address => bool)) public _operatorsForAll;\\n    mapping (uint256 => address) public _operators;\\n\\n    uint256 internal _nextId = 1;\\n\\n    constructor(address metaTxProcessor) public EIP1776MetaTxReceiverBase(metaTxProcessor) {}\\n\\n    function isValidApproveOperator(address from) internal returns (bool) {\\n        return isValidSender(from) || _operatorsForAll[from][msg.sender];\\n    }\\n\\n    function mint(address to) external {\\n        // TODO only specified minter can do\\n        uint256 id = _nextId++;\\n        uint256 index = _itemsPerOwner[to].length;\\n        _itemsPerOwner[to].push(id);\\n        _ownerAndIndex[id] = uint256(to) + index * 2**160;\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _transferFrom(address from, address to, uint256 id, bool safe, bytes memory data) internal {\\n        (address owner, uint256 index, bool operatorEnabled) = _ownerIndexAndOperatorEnabledOf(id);\\n        require(owner != address(0), \\\"DOES_NOT_EXIST\\\");\\n        require(owner == from, \\\"NOT_OWNER\\\");\\n        require(to != address(0), \\\"ZERO_ADDRESS\\\");\\n        bool isMeta = isMetaTx();\\n        if (msg.sender != from && !isMeta) {\\n            require(\\n                _operatorsForAll[from][msg.sender] ||\\n                (operatorEnabled && _operators[id] == msg.sender),\\n                \\\"NOT_AUTHORIZED\\\"\\n            );\\n        }\\n\\n        uint256 lastItemId = _itemsPerOwner[from][_itemsPerOwner[from].length-1]; // TODO for silidity: should pop return the item ?\\n        _itemsPerOwner[from].pop();\\n        if (id != lastItemId) {\\n            _itemsPerOwner[from][index] = lastItemId;\\n            _ownerAndIndex[lastItemId] = uint256(from) + index * 2**160;\\n        }\\n\\n        uint256 newIndex = _itemsPerOwner[to].length;\\n        _itemsPerOwner[to].push(id);\\n        _ownerAndIndex[id] = uint256(to) + newIndex * 2**160;\\n        emit Transfer(from, to, id);\\n        if (safe && to.isContract()) {\\n            require(\\n                _checkOnERC721Received(isMeta ? from : msg.sender, from, to, id, data),\\n                \\\"ERC721_TRANSFER_FAILED\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Return the number of Land owned by an address\\n     * @param owner The address to look for\\n     * @return The number of Land token owned by the address\\n     */\\n    function balanceOf(address owner) external view returns (uint256) {\\n        require(owner != address(0), \\\"owner is zero address\\\");\\n        return _itemsPerOwner[owner].length;\\n    }\\n\\n\\n    function _ownerOf(uint256 id) internal view returns (address tokenOwner) {\\n        tokenOwner = address(_ownerAndIndex[id]);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\\n        uint256 data = _ownerAndIndex[id];\\n        owner = address(data);\\n        operatorEnabled = (data / 2**255) == 1;\\n    }\\n\\n    function _ownerIndexAndOperatorEnabledOf(uint256 id) internal view returns (address owner, uint256 index, bool operatorEnabled) {\\n        uint256 data = _ownerAndIndex[id];\\n        owner = address(data);\\n        index = (data & 0xEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) / 2**160;\\n        operatorEnabled = (data / 2**255) == 1;\\n    }\\n\\n    /**\\n     * @notice Return the owner of a Land\\n     * @param id The id of the Land\\n     * @return owner The address of the owner\\n     */\\n    function ownerOf(uint256 id) external view returns (address owner) {\\n        owner = _ownerOf(id);\\n        require(owner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function _approveFor(address sender, address operator, uint256 id) internal {\\n        (address owner, uint256 index, bool operatorEnabled) = _ownerIndexAndOperatorEnabledOf(id);\\n        require(owner != address(0), \\\"DOES_NOT_EXIST\\\");\\n        require(owner == sender, \\\"NOT_OWNER\\\");\\n        if(operator == address(0)) {\\n            _ownerAndIndex[id] = uint256(owner) + index * 2**160; // no need to resset the operator, it will be overriden next time\\n        } else {\\n            _ownerAndIndex[id] = uint256(owner) + index * 2**160 + 2**255;\\n            _operators[id] = operator;\\n        }\\n        emit Approval(owner, operator, id);\\n    }\\n\\n    /**\\n     * @notice Approve an operator to spend tokens on the sender behalf\\n     * @param sender The address giving the approval\\n     * @param operator The address receiving the approval\\n     * @param id The id of the token\\n     */\\n    function approveFor(\\n        address sender,\\n        address operator,\\n        uint256 id\\n    ) external {\\n        require(sender != address(0), \\\"ZERO_ADDRESS\\\");\\n        require(isValidApproveOperator(sender), \\\"NOT_AUTHORIZED\\\");\\n        _approveFor(sender, operator, id);\\n    }\\n\\n    /**\\n     * @notice Approve an operator to spend tokens on the sender behalf\\n     * @param operator The address receiving the approval\\n     * @param id The id of the token\\n     */\\n    function approve(address operator, uint256 id) external {\\n        address owner = _ownerOf(id);\\n        // NO META TX here as the first parameter is not the originator but the operator that is meant to be approved\\n        require(\\n            owner == msg.sender || // TODO remove duplicatre check\\n            _operatorsForAll[owner][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n        _approveFor(owner, operator, id);\\n    }\\n\\n    /**\\n     * @notice Get the approved operator for a specific token\\n     * @param id The id of the token\\n     * @return The address of the operator\\n     */\\n    function getApproved(uint256 id) external view returns (address) {\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\n        require(owner != address(0), \\\"DOES_NOT_EXIST\\\");\\n        if (operatorEnabled) {\\n            return _operators[id];\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer a token between 2 addresses\\n     * @param from The sender of the token\\n     * @param to The recipient of the token\\n     * @param id The id of the token\\n    */\\n    function transferFrom(address from, address to, uint256 id) external {\\n        _transferFrom(from, to, id, false, \\\"\\\");\\n    }\\n\\n    /**\\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\\n     * @param from The sender of the token\\n     * @param to The recipient of the token\\n     * @param id The id of the token\\n     * @param data Additional data\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public {\\n        _transferFrom(from, to, id, true, data);\\n    }\\n\\n    /**\\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\\n     * @param from The send of the token\\n     * @param to The recipient of the token\\n     * @param id The id of the token\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id) external {\\n        safeTransferFrom(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @notice Check if the contract supports an interface\\n     * 0x01ffc9a7 is ERC-165\\n     * 0x80ac58cd is ERC-721\\n     * 0x780e9d63 is ERC-721 Enumerable Extension\\n     * @param id The id of the interface\\n     * @return True if the interface is supported\\n     */\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x780e9d63;\\n    }\\n\\n    /**\\n     * @notice Set the approval for an operator to manage all the tokens of the sender\\n     * @param sender The address giving the approval\\n     * @param operator The address receiving the approval\\n     * @param approved The determination of the approval\\n     */\\n    function setApprovalForAllFor(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) external {\\n        require(sender != address(0), \\\"ZERO_ADDRESS\\\");\\n        require(\\n            isValidSender(sender),\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        _setApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /**\\n     * @notice Set the approval for an operator to manage all the tokens of the sender\\n     * @param operator The address receiving the approval\\n     * @param approved The determination of the approval\\n     */\\n    function setApprovalForAll(address operator, bool approved) external {\\n\\n        // NOT META TX ...\\n        _setApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n\\n    function _setApprovalForAll(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal {\\n        _operatorsForAll[sender][operator] = approved;\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /**\\n     * @notice Check if the sender approved the operator\\n     * @param owner The address of the owner\\n     * @param operator The address of the operator\\n     * @return isOperator The status of the approval\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool isOperator)\\n    {\\n        return _operatorsForAll[owner][operator];\\n    }\\n\\n    function _checkOnERC721Received(address operator, address from, address to, uint256 tokenId, bytes memory _data)\\n        internal returns (bool)\\n    {\\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    /////////////// erc721 ENUMERABLE //////////////\\n    function totalSupply() external view returns (uint256) {\\n        return _nextId - 1;\\n    }\\n    function tokenByIndex(uint256 index) external view returns (uint256) {\\n        revert(\\\"NOT SUPPORTED\\\");\\n    }\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\\n        return _itemsPerOwner[owner][index];\\n    }\\n}\\n\",\"keccak256\":\"0xbb39c793b52c65fbf25ee8368bdb63a01786857e1c8ac15506731053eec8e3b3\"}},\"version\":1}",
    "userdoc": {
      "methods": {}
    }
  },
  "args": [
    "0x8C64017cDD6B318f29610bB92AC9973eD1B85F44",
    "0x5565e1F4b5707920437e2c427d56d8022a247C93",
    "1000000000000000000",
    "0x172690708ea4Ca089088398d1118685CE798560a"
  ],
  "address": "0x87ba3A5C52bC761AEA755603070d665Ab3375A09",
  "transactionHash": "0x065bef30a847467a8906d0111cd5c902cc6ea52f52e223b2d4710c040de75940"
}